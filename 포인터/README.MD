# 포인터
포인터는 직접적으로 메모리에 접근이 가능하다.

## 포인터 변수
메모리 주소 값을 저장하기 위한 변수다.

```c
#include <stdio.h>

int main(void)
{
    int num = 7;
    int * pnum; // pointer 변수 pnum선언
    pnum = &num; // pnum에 num 변수를 할당

    printf("%d", *pnum);
    return 0;
}
```
포인터 변수는 선언 후 반드시 유효한 메모리 주소로 초기화하여 사용해야하며 초기화 되지 않은 포인터 변수는 예기치 않은 오류를 발생시킬 수 있기 때문이다.

&연산자의 결과로 변수 num의 주소 값이 반환되며, 이를 포인터 변수인 pnum에 저장한다.

## 포인터의 형(Type)
int, char, double 등 변수의 선언의 필요한 형태를 자료형이라고 하듯 포인터 변수가 선언 및 구분에 사용되는 것을 포인터 형이라고 한다.

포인터 변수에서 &다음에 변수명이 들어와야 한다. 만약 변수명이 아닌 다른 값이 들어오면 컴파일러에서 오류가 발생한다.

또한 포인터 변수와 가르키는 변수의 타입은 반드시 같아야 한다.

## 포인터 변수에 다양한 형이 존재하는 이유
포인터 변수에 다양한 형이 존재하는 이유는 **메모리 공간을 참조하는 기준**이 되기 때문이다. 또한, 포인터 형은 포인터 연산(예: 주소의 증감)에도 영향을 주어, 연산 시 해당 형의 크기만큼 자동으로 증가하거나 감소하게 된다.

위 코드에서 pnum은 int 형으로 선언되었고 가르키고 있는 주소를 시작으로 4바이트를 읽어 들여서 이를 정수로 해석해야한다. 그렇기에 포인터 타입과 포인터가 가르키는 변수의 타입이 같아야 하는 이유는

double로 선언된 변수는 8바이트를 적재해야한다. 하지만 만약 int 형 포인터 변수에 이를 넣게 된다면 메모리 오버플로우가 발생해 프로그램이 비이상적으로 종료될 수 있기 때문이다. 또한 타입이 일치하지 않을 경우, 메모리 오버플로우뿐만 아니라 정의되지 않은 동작(undefined behavior)이 발생할 수 있으므로, 반드시 **포인터 변수의 형과 가리키는 데이터의 형을 일치**시켜야 한다.

## 잘못된 포인터의 사용과 Null 포인터

```c
#include <stdio.h>

int main(void)
{
    int * pnum;
   *pnum = 100;

    return 0;
}
```
위 코드가 바로 포인터의 잚못된 사용법이다.

위 코드에서는 int 형태의 포인터 pnum을 선언했지만 초기화는 그 다음 줄에 되어있다. 만약 이런식으로 포인터 변수를 선언만 하고 초기화하지 않으면 포인터 변수에는 쓰레기 값이 저장된다. 또한 이러한 상태에서 100이라는 값을 저장하는 행위는 치명적인 결함을 이르킬 수 있다.

만약 저 상태에서 pnum에 100이라는 값을 집어넣을 때, 적재되는 메모리의 공간이 중요한 위치였다면, 시스템에 심각한 문제를 일으킬 수도 있는 상황이된다.

만약 포인터 변수 선언을 했지만 후에 값을 넣어 줄 것이라면 **NULL**이라는 값으로 초기화 하는 것이 좋다.

```c
#include <stdio.h>

int main(void)
{
    int * pnum = null;
   *pnum = 100;

    return 0;
}
```
이처럼 NULL이라는 값을 넣어주면 **아무데도 가르키지 않는다는 의미를 지닌다.**